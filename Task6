1. Write a function that calculates the ratio of the mean and the median of a given vector.

mean_median_ratio <- function(x) {
  if (!is.numeric(x)) {
    stop("Input must be a numeric vector.")
  }
  mean_val <- mean(x, na.rm = TRUE)
  median_val <- median(x, na.rm = TRUE)
  
  if (median_val == 0) {
    warning("Median is zero; ratio may be infinite or undefined.")
    return(NA)
  }
  
  return(mean_val / median_val)
}

2. Write a function that ignores the lowest and the highest value from a given vector and calculate the mean.

trimmed_mean <- function(x) {
  if (!is.numeric(x)) {
    stop("Input must be a numeric vector.")
  }
  
  x <- sort(x, na.last = NA)  # Sort and remove NA values
  if (length(x) <= 2) {
    warning("Vector must contain more than two values to exclude min and max.")
    return(NA)
  }
  
  trimmed <- x[-c(1, length(x))]  # Remove first (min) and last (max)
  return(mean(trimmed))
}

3. Read about piping from here:https://r4ds.had.co.nz/pipes.html#pipes (you don’t have to learn everything, a basic understanding of the usage is enough). Write a short
(max. 300 characters, no spaces) explanation of why, how, and when not to use pipes.

Pipes (%>%) in R are used to make code more readable by expressing a sequence of operations in a linear, step-by-step format. They are especially useful in data transformation workflows, allowing the user to avoid nested function calls and write code that flows logically. 
Pipes work by passing the output of one function as the first argument to the next, which is ideal when working with functions that take a data frame as their first input. The user can also use the dot (.) to specify where the piped object should go if it’s not the first argument. 
However, pipes are not always appropriate. They should be avoided when dealing with complex logic, such as loops or branching conditions, where clarity is better served by breaking the code into smaller parts. Pipes also make debugging harder because intermediate results are not easily inspected. 
Functions that require multiple inputs from different sources may not work well with pipes, and some functions behave unpredictably due to non-standard evaluation. Additionally, when the code involves side effects or assignments, using named variables is often clearer than chaining operations with pipes.






