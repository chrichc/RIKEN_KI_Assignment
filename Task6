1. Write a function that calculates the ratio of the mean and the median of a given vector.

mean_median_ratio <- function(x) {
  if (!is.numeric(x)) {
    stop("Input must be a numeric vector.")
  }
  mean_val <- mean(x, na.rm = TRUE)
  median_val <- median(x, na.rm = TRUE)
  
  if (median_val == 0) {
    warning("Median is zero; ratio may be infinite or undefined.")
    return(NA)
  }
  
  return(mean_val / median_val)
}

2. Write a function that ignores the lowest and the highest value from a given vector and calculate the mean.

trimmed_mean <- function(x) {
  if (!is.numeric(x)) {
    stop("Input must be a numeric vector.")
  }
  
  x <- sort(x, na.last = NA)  # Sort and remove NA values
  if (length(x) <= 2) {
    warning("Vector must contain more than two values to exclude min and max.")
    return(NA)
  }
  
  trimmed <- x[-c(1, length(x))]  # Remove first (min) and last (max)
  return(mean(trimmed))
}

3. Read about piping from here:https://r4ds.had.co.nz/pipes.html#pipes (you don’t have to learn everything, a basic understanding of the usage is enough). Write a short
(max. 300 characters, no spaces) explanation of why, how, and when not to use pipes.

Pipes (%>%) in R are used to make code more readable by expressing a sequence of operations in a linear, step-by-step format. They are especially useful in data transformation workflows, allowing the user to avoid nested function calls and write code that flows logically. 
Pipes work by passing the output of one function as the first argument to the next, which is ideal when working with functions that take a data frame as their first input. The user can also use the dot (.) to specify where the piped object should go if it’s not the first argument. 
However, pipes are not always appropriate. They should be avoided when dealing with complex logic, such as loops or branching conditions, where clarity is better served by breaking the code into smaller parts. Pipes also make debugging harder because intermediate results are not easily inspected. 
Functions that require multiple inputs from different sources may not work well with pipes, and some functions behave unpredictably due to non-standard evaluation. Additionally, when the code involves side effects or assignments, using named variables is often clearer than chaining operations with pipes.

4. Familiarize yourself with the apply-family of functions (apply, lapply, sapply etc.) http://uc-r.github.io/apply_family
Write a short explanation (max. 300 characters, no spaces) of why they could be useful in your work.

The apply family in R, including apply(), lapply(), sapply(), tapply(), mapply(), and vapply()—offers powerful tools for performing repetitive operations across data structures like vectors, matrices, and lists. 
These functions help streamline code, reduce the need for explicit loops, and improve performance and readability. 
In RNA-Sequencing analysis, these functions are especially useful for handling gene expression count matrices and metadata:
apply() can be used to compute summary statistics (e.g., mean, variance) across genes or samples.
lapply() and sapply() are useful for applying normalization or transformation functions to each sample or gene.
tapply() helps in aggregating expression data by experimental conditions or gene categories.
mapply() can be used to apply gene-specific models across multiple genes simultaneously.
These functions integrate well with Bioconductor packages like DESeq2 or edgeR, allowing users to preprocess, filter, and analyze large-scale RNA-Seq data efficiently.
By applying the apply family, we can write concise, scalable code for RNA-Seq analysis, improving reproducibility and reducing computational overhead.


